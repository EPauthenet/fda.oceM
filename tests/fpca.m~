function [pca] = fpca(fdobj)
% Functional Principal Component Analysis of hydrographic profiles
%
% fdobj : functional object containing an array of the splines in that
% order nbas * nobs * nvar
%
% return a "pca object
%
% @references Ramsay J. O., and B. W. Silverman, 2005: Functional Data Analysis. Springer, 426 pp.
%
% @seealso \code{\link{bspl}} for bsplines fit on T-S profiles, \code{\link{PCmap}} for plotting a map of PC, \code{\link{kde_pc}} for kernel density estimation of two PCs...


coef  = getcoef(fdobj);
metric = eval_penalty(basis);

nbas   = getnbasis(basis);
nobs   = size(coef,2);
ndim   = size(coef,3);
prange = getbasisrange(basis);
depth  = (prange(1):prange(2))';

pca = [];
pca.basis = basis;
pca.metric = metric;
pca.nbas = nbas;
pca.nobs = nobs;
pca.ndim = ndim;
pca.fdnames = getnames(fdobj);

C = zeros(nobs,ndim*nbas);
for kk=1:ndim,
    C(:,(kk-1)*nbas+1:kk*nbas) = squeeze(coef(:,:,kk))';
end

Cm = mean(C,1);
Cc = C - repmat(Cm,nobs,1);
pca.Cm = Cm;

% inertia
inertia=zeros(ndim,1);
for kk=1:ndim,
    V = Cc(:,(kk-1)*nbas+1:kk*nbas)'*Cc(:,(kk-1)*nbas+1:kk*nbas)*metric/nobs;
    inertia(kk) = trace(V);
end
pca.inertia = inertia;

% metric M
M = zeros(ndim*nbas);
Mdeminv = zeros(ndim*nbas);
for kk=1:ndim,
    M((kk-1)*nbas+1:kk*nbas,(kk-1)*nbas+1:kk*nbas)=diag(ones(nbas,1)/inertia(kk));
    Mdeminv((kk-1)*nbas+1:kk*nbas,(kk-1)*nbas+1:kk*nbas)=diag(ones(nbas,1)*sqrt(inertia(kk)));
end
Mdem = sqrt(M);

% metric W
W = [];
for kk=1:ndim,
    W = blkdiag(W,metric);
end
W = (W+W')/2;
pca.W = W;
Wdem = chol(W);
Wdeminv = inv(Wdem);

% Cov matrix
V = 1/nobs * Mdem * Wdem * Cc' * Cc * Wdem' * Mdem;
[pca_vectors,pca_values] = eig(V,'vector');
[pca_values,I] = sort(pca_values,'descend');
pca_vectors = pca_vectors(:,I);

% create FPCA
pca.values = pca_values;
pca.pval = 100 * pca.values / sum(pca.values);
pca.vecnotWM = pca_vectors;
pca.M = M;
pca.vectors = Mdeminv * Wdeminv * pca_vectors;
pca.axes = pca.vectors .* repmat(sqrt(pca.values),1,ndim*nbas);

%% comments
% Verif0 = pca.vectors(:,1)' * W * M * pca.vectors(:,1) - 1;
% Verif1 = pca.vectors(:,1)' * W * M * pca.vectors(:,2);
% Verif2 = pca.values(1) - 1/nobs*pca.pc(:,1)'*pca.pc(:,1);
% 
% plot(pca.pc(:,1),pca.pc(:,2),'.')
% plot3(pca.pc(:,1),pca.pc(:,2),pca.pc(:,3),'.')

